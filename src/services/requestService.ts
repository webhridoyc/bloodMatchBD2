
'use server';

import { collection, addDoc, getDocs, serverTimestamp, query, orderBy, Timestamp } from "firebase/firestore";
import { db } from '@/lib/firebase';
import type { BloodRequest, BloodGroup, UrgencyLevel } from '@/types';

const requestsCollectionRef = collection(db, 'requests');

// Type for data being added (ID is auto-generated by Firestore)
// Includes postedDate as it's set on the client before sending
export type NewRequestData = {
  patientName: string;
  bloodGroup: BloodGroup;
  location: string;
  urgency: UrgencyLevel;
  contact: string;
  hospitalName?: string;
  notes?: string;
  postedDate: string; // ISO String
};

export async function addRequest(requestData: NewRequestData): Promise<string> {
  try {
    // You could add a server-side timestamp for internal record-keeping if needed
    // const docData = { ...requestData, createdAt: serverTimestamp() };
    const docRef = await addDoc(requestsCollectionRef, requestData);
    console.log("Blood request added with ID: ", docRef.id);
    return docRef.id;
  } catch (error: any) {
    console.error("Error adding blood request to Firestore: ", error);
    if (error.code === 'permission-denied') {
      throw new Error("Failed to post blood request: Permission denied. Please check your Firestore security rules.");
    }
    throw new Error("Failed to post blood request. Please try again.");
  }
}

export async function getRequests(): Promise<BloodRequest[]> {
  try {
    // Order requests by postedDate in descending order (newest first)
    const q = query(requestsCollectionRef, orderBy("postedDate", "desc"));
    const querySnapshot = await getDocs(q);

    const requests = querySnapshot.docs.map(doc => {
      const data = doc.data();
      // Ensure all fields of BloodRequest type are present
      return {
        id: doc.id,
        patientName: data.patientName || 'N/A',
        bloodGroup: data.bloodGroup || 'Unknown', // Should ideally be validated
        location: data.location || 'N/A',
        urgency: data.urgency || 'Low', // Should ideally be validated
        contact: data.contact || 'N/A',
        hospitalName: data.hospitalName, // Optional
        // Ensure postedDate is handled correctly. If it was a Firestore Timestamp, you'd use:
        // postedDate: (data.postedDate as Timestamp)?.toDate().toISOString() || new Date().toISOString(),
        // For now, assuming it's stored as an ISO string as per NewRequestData
        postedDate: data.postedDate || new Date().toISOString(),
        notes: data.notes, // Optional
      } as BloodRequest;
    });
    return requests;
  } catch (error) {
    console.error("Error fetching blood requests from Firestore: ", error);
    // Return empty array or re-throw, depending on how you want to handle errors UI-side
    return [];
  }
}
