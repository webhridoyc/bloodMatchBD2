
'use server'; // Can be used by Server Components

import { collection, addDoc, getDocs, serverTimestamp, query, orderBy } from "firebase/firestore";
import { db } from '@/lib/firebase';
import type { Donor, BloodGroup } from '@/types';

const donorsCollectionRef = collection(db, 'donors');

// Type for data being added (ID is auto-generated by Firestore)
export type NewDonorData = {
  name: string;
  bloodGroup: BloodGroup;
  location: string;
  contact: string;
  // createdAt?: any; // If you want to use serverTimestamp
};

export async function addDonor(donorData: NewDonorData): Promise<string> {
  try {
    const docRef = await addDoc(donorsCollectionRef, donorData);
    console.log("Donor (server) added with ID: ", docRef.id);
    return docRef.id;
  } catch (error) {
    // Log the detailed error on the server for debugging
    console.error("Firestore 'addDonor' service error:", error);

    let errorMessage = "Failed to register donor due to a server-side issue. Please check server logs and try again later.";
    if (error instanceof Error) {
      // Check for specific Firebase error codes if available, e.g., error.code
      // For a generic timeout or unreachability, the message might be vague.
      if (error.message.toLowerCase().includes('deadline_exceeded') || error.message.toLowerCase().includes('timeout')) {
        errorMessage = "Failed to register donor: The request to the database timed out. This might be a temporary network issue or a problem with the database service. Please try again shortly.";
      } else if (error.message.toLowerCase().includes('permission_denied') || (error as any).code === 'permission-denied') {
         errorMessage = "Failed to register donor: Database permission denied. Please check your Firestore security rules and server configuration.";
      } else {
        // Include the original error message for more context if it's not one of the above
        errorMessage = `Failed to register donor: ${error.message}. Please try again later.`;
      }
    }
    // This error will be caught by the client-side form if the Server Action itself doesn't time out first.
    throw new Error(errorMessage);
  }
}

export async function getDonors(): Promise<Donor[]> {
  try {
    // Example: Order donors by name. You can add more complex queries or ordering.
    const q = query(donorsCollectionRef, orderBy("name")); 
    const querySnapshot = await getDocs(q);
    
    const donors = querySnapshot.docs.map(doc => {
      const data = doc.data();
      // Ensure all fields of Donor type are present, provide defaults or handle missing fields if necessary
      return {
        id: doc.id,
        name: data.name || 'N/A',
        bloodGroup: data.bloodGroup || 'Unknown',
        location: data.location || 'N/A',
        contact: data.contact || 'N/A',
        // If you added createdAt and want to convert it:
        // createdAt: data.createdAt?.toDate().toISOString() || new Date().toISOString(), 
      } as Donor;
    });
    return donors;
  } catch (error) {
    console.error("Error fetching donors from Firestore: ", error);
    // Depending on usage, you might want to return empty array or re-throw
    // For client components, it's often better to return empty or a specific error state.
    throw new Error("Failed to fetch donors. Please try again later.");
  }
}
